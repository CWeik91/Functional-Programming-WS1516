\documentclass{article}
\title{Funktionale Programmierung Mitschrieb}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{nicefrac}
\fancyhf{}
\fancyhead[C]{Torsten Grust - Functional Programming}
\usepackage{fontspec}
\setmonofont{Andale Mono}
\usepackage[english]{babel}
\author{Finn Ickler}
\usepackage{mdframed}
\usepackage{tikz}
\usepackage{epigraph}
\usepackage{minted}
\renewcommand{\listingscaption}{Code example}
\newcommand{\Haskell}[1]{\mintinline{Haskell}{#1}}
\setcounter{secnumdepth}{-1}
\hypersetup{%
pdfborder = {0 0 0}
}
\begin{document}
\maketitle
\epigraph{\glqq Avoid success at all cost \grqq}{Simon Peyton Jones}
\tableofcontents
\listoflistings
\section{Vorlesung 1}
\begin{listing}
\caption{Hello World}
\begin{minted}{haskell}
-- Hello World Haskell
main :: IO ()
main = putStrLn "Chewie, we're home"
\end{minted}
\end{listing}
\subsection{Functional Programming (FP)}
A programming language is a medium for expressive ideas (not to get a computer to perform operations ). Thus programs must be written for people to read, and only incidentally for machines.
\subsection{Computational Model in FP : \emph{Reduction}}
Replace expressions by their value.\\
IN FP, expressions are formed by applying functions to values.
\begin{enumerate}
\item Function as in maths: $x = y \rightarrow f(x) = f(y)$
\item Functions are values like numbers or text
\end{enumerate}
\begin{tabular}{l|c|c}
&FP&Imperative\\
construction & function application and composition & statement sequencing\\
execution & reduction (expression evaluation) & state changes\\
semantics & $\lambda$-calculus&denotational
\end{tabular}\bigskip\\
$ n \in \mathbb{N}, n \geq 2$ is a prime number $\Leftrightarrow$ the set of non-trivial factors of n is empty.\\
$n$ is prime $\Leftrightarrow \{ m \mid m \in m \in \{2,\ldots,n-1\}, n mod m = 0 \} = \{\}$\\
\begin{listing}[h!]
\begin{minted}{c}
int IsPrime(int n)
{
    int m;
    int found_factor;
    found_factor
    for (m = 2; m <= n -1; m++)
    {
        if (n % m == 0)
        {
            found_factor = 1 ;
            break;
        }
    }
    return !found_factor;
}
\end{minted}
\caption{isPrime in C}
\end{listing}
\begin{listing}[h!]
\begin{minted}{Haskell}
isPrime :: Integer -> Bool
isPrime n = factors n == []
  where 
    factors :: Integer -> [Integer]
    factors n = [ m  | m <- [2..n-1], mod n m == 0]

main :: IO ()
main = do
  let n = 42
  print (isPrime n)
\end{minted}
\caption{isPrime in Haskell}
\end{listing}
\newpage
\usemintedstyle[Haskell]{bw}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\begin{listing}[h!]
\begin{minted}[bgcolor=bg]{Haskell}
let xs = [ x+1 | x <- [0..9] ]
:sprint xs = _
length xs
:sprint xs = [_,_,_,_,_,_,_,_,_]
\end{minted}
\caption{Lazy Evaluation in der ghci REPL}
\end{listing}
\usemintedstyle[Haskell]{default}
\subsection{Haskell Ramp Up}
Read $\equiv$ as ''denotes the same value as''\\
Apply f to value e:\quad f \textvisiblespace e \\(juxtaposition, ''apply'', binary operator \textvisiblespace, Haskell speak: infixL 10 \textvisiblespace)
= \textvisiblespace has max precedence (10): f $e_1$ +$e_2 \equiv $(f $e_1$) + $e_2$
\textvisiblespace associates to the left g \textvisiblespace f \textvisiblespace e $\equiv$ (g f) e
Function composition:
\begin{enumerate}[-]
\item g (f e)
\item Operator ''.'' (''after'') : (g.f) e (. = $\circ$) = g(f (e))
\item Alternative ''apply'' operator \$ (lowest precedence, associates to the right), infix 0\$): f\$$e_1$+ $e_2$ = f ($e_1 + e_2$)
\end{enumerate}
\section{Vorlesung 2}
\begin{listing}
\caption{Verschiedene Schreibweise einer Applikation}
\begin{minted}[bgcolor=bg]{Haskell}
cos 2 * pi
cos (2 * pi)
cos $ 2 * pi
isLetter (head (reverse ("It's a " ++ "Trap")))
(isLetter . head . reverse ) ("It's a" ++ "Trap")
isLetter $ head $ reverse $ "It's a" ++ "Trap"
\end{minted}
\end{listing}
\noindent Prefix application of binary infix operator $\oplus$
\begin{minted}[escapeinside=||]{Haskell}
(|$\oplus) e_1 e_2 \equiv e_1 \oplus e_2$|
|$(\&\&)$| True False |$\equiv$| False
\end{minted}
Infix application of binary function f:
\begin{minted}[escapeinside=||]{Haskell}
|$e_1$| `f` |$e_2$| |$\equiv$| f |$e_1 e_2$|
x `elem` xs |$\equiv$| x |$\in$| xs
\end{minted}
User defined operators with characters : \mintinline{Haskell}|!#%&*+/<=>?@\^|~|
\begin{listing}
\caption{Eigener $\approx$ Opperator}
\begin{minted}{Haskell}
epsilon :: Double
epsilon = 0.00001
(~=~) :: Double -> Double -> Bool
x ~=~ y = abs (x - y) < epsilon
infix 4 ~=~ 
\end{minted}
\end{listing}
\subsection{Values and Types}
Read \mintinline{Haskell}|::| as ''has type''\\
Any Haskell value e has a type t (\mintinline{Haskell}{e::t}) that is determined at compile time.\\
The \mintinline{Haskell}|::| type assignment is either given explicitly or inferred by the computer
\subsection{Types}
\begin{tabular}{lll}
Type&Description&Value\\
\hline
Int & fixed precision integers ($-2^{63}\ldots2^{63}-1$)&\Haskell{0,1,42}\\
Integer & arbitrary Precision integers & \Haskell{0,10^100}\\
Float,Double & Single/Double precision floating points & \Haskell{0.1,1e03}\\
Char & Unicode Character&\mintinline[escapeinside=||]{Haskell}{'x','\t', 'â–³', '\8710'}\\
Bool & Booleans & \mintinline[escapeinside=||]{Haskell}{True, False}\\
() & Unit (single-value type) & \mintinline[escapeinside=||]{Haskell}{()}
\end{tabular}
\begin{minted}[bgcolor =bg]{Haskell}
2
it :: Integer
42 :: Int 
it :: Int
'a' 
it :: Char
True 
it :: Bool
10^100 
it :: Integer
10^100 :: Double 
it :: Double
\end{minted}
\subsection{Type Constructors}
\begin{itemize}
\item Build new types from existing Types
\item Let a,b denote arbitrary Types (type variables)
\end{itemize}
\begin{tabular}{lp{6cm}l}
Type Constructor& Description & Values\\
\hline
(a,b)&pairs of values of types a and b& \Haskell{(1,True) :: (Int, Bool)}\\
($\text{a}_1,\text{a}_2,\ldots,\text{a}_n$)& n-Types& \Haskell{2,False :: (Int, Bool)}\\
\Haskell{[a]} &list of values of type a & \Haskell{[] :: [a]}\\
\Haskell{Maybe} a & optional value of type a & \Haskell{Just 42 Maybe Integer}\\
& & \Haskell{Nothing :: Maybe a}\\
\Haskell{Either} a b & Choice between values of Type a and b& \Haskell{Left 'x' :: Either Char b}\\
& & \Haskell{Right pi :: Either a Double}\\
\Haskell{IO} a & I/O action that returns a value of type a (can habe side effects ) & \Haskell{print 42 :: IO} ()\\
& & \Haskell{getChar :: IO Char}\\
a \Haskell{->} b & function from type a to b & \Haskell{isLetter :: Char -> Bool}
\end{tabular}
\begin{minted}[bgcolor=bg]{Haskell}
(1, '1', 1.0)
it :: (Integer, Char, Double)
[1, '1', 1.0]
it :: Fehler
[0.1,1.0,0.01] 
it :: [Double]
[]
it :: [t]
"Yoda"
it :: [Char]
['Y', 'o', 'd', 'a']
"Yoda"
[Just 0, Nothing, Just 2] 
it :: [Maybe Integer]
[Left True, Right 'a']
it :: [Either Bool Char]
print 'x' 
it :: ()
getChar
*
it :: Char
:t getChar
getChar :: Io Char
:t fst 
fst :: (a,b) -> a
:t snd
snd :: (a,b) -> b
:t head
head :: [a] -> a
:t (++)
(++) :: [a] -> [a] -> [a]
\end{minted}
\subsection{Currying}
\begin{itemize}
\item Recall:\begin{enumerate}
\item $e_1$ \Haskell{++} $e_2 \equiv$ \Haskell{(++)} $e_1 e_2$
\item \Haskell{++} $e_1 e_2 \equiv$ \Haskell{((++)} $e_1) e_2$
\end{enumerate}
\item Function application happens one argument at a time (currying, Haskell B. Curry)
\item Type of n-ary function: : $a_1$ \Haskell{->} $a_2$ \Haskell{... ->} $a_n$ \Haskell{-> b}
\item Type constructor \Haskell{->} associates to the right thus read the type as:\\ $a_1$ \Haskell{->} ($a_2$ \Haskell{->} $a_3$ (\Haskell{... ->} ($a_n$ \Haskell{-> b})\ldots))
\item Enables partial application: ''Give me a value of type $a_1$, I'll give you a (n-1)-ary function of type $a_2$ \Haskell{->} $a_3$ \Haskell{-> ... ->} $a_n$ \Haskell{-> b}
\end{itemize}
\begin{minted}[bgcolor = bg]{Haskell}
"Chew" ++ "bacca"
"Chewbacca"
(++) "Chew" "bacca"
"Chewbacca"
((++) "Chew") "bacca"
"Chewbacca"
:t (++) "Chew"
"Chew" :: [Char] -> [Char]
let chew = (++) "Chew"
chew "bacca"
"Chewbacca"
let double (*) 2
double 21
42
\end{minted}
\section{Vorlesung 3}
\subsection{Defining Values (and thus: Functions)}
\begin{itemize}
\item = binds names to values, names must not start with A-Z (Haskell style: camelCase)
\item Define constant (0-ary) c, value of c is that of expression:\\
c = e
\item Define n-ary function, arguments $x_i$ and f may occur in e (no "letrec" needed)\\
f $x_1\ x_2\ldots x_n = e$
\item Hskell programm = set of top-level bindings (order immaterial, no rebinding)
\item Good style: give type assignment for top-level bindings:\\
\Haskell{f :: a1 -> a2 -> b}\\
\Haskell{f } $x_1$ $x_2$ \Haskell{= e}
\begin{listing}[h!]
\caption{fac in Haskell}
\begin{minted}{Haskell}
fac :: Integer -> Integer
fac n = if n <= 1 then 1 else n * fac (n - 1)

fac2 n | n <= 1    = 1
       | otherwise = n * fac2 (n - 1)

main :: IO ()
main = print $ fac 10
\end{minted}
\end{listing}
\item Guards (introduced by $\vert$).
\begin{minted}[escapeinside=@@]{Haskell}
f @$x_1\ x_2\ \ldots\ x_n$@
  |@$q_1$@ = @$e_1$@
  |@$q_2$@ = @$e_n$@
\end{minted}
\begin{listing}[h!]
\caption{Power in Haskell}
\begin{minted}{Haskell}
power :: Double -> Integer -> Double
power x k | k == 1 = x
          | even k = power (x * x) (halve k)
          | otherwise = x * power (x * x) (halve k)
  where
    even :: Integer -> Bool -- Nicht typisch
    even n  = n `mod` 2 == 0
    halve n = n `div` 2

main :: IO ()
main = print $ power 2 16 
\end{minted}
\end{listing}
\item $q_i$ (expressions of type Bool) evaluated top to bottom, first True guards ''wins''\\
$\mathrm{fac}\ n = \begin{cases}
1 &if n \geq 1\\
n \cdot \mathrm{fac(n-1)}& else
\end{cases}$\\
\end{itemize}
\subsection{Lokale Definitionen}
\begin{enumerate}
\item \Haskell{where} - binding : Local definitions visible in the entire right-hand-side (rhs) of a definition
\begin{minted}[escapeinside=@@]{Haskell}
f @$x_1\ x_2\ \ldots\ x_n$@
  |@$q_1$@ = @$e_1$@
  |@$q_2$@ = @$e_n$@
 where 
    @$g_1$@ ... = @$b_1$@
    @$g_i$@ ... = @$b_i$@
\end{minted}
\item \Haskell{let} - expression Local definitions visible inside an expression:
\begin{minted}[escapeinside=@@]{Haskell}
let @$g_1$@ ... = @$b_1$@
    @$g_2$@ ... = @$b_1$@
in e
\end{minted}
\end{enumerate}
\section*{Haskells 2-dimensionale Syntax (Layout) (Forumbeitrag)}
\begin{mdframed}
Hallo zusammen,\\
in der dritten Vorlesung hatte ich erwÃ¤hnt, dass Haskells Syntax darauf verzichtet, BlÃ¶cke (von Definitionen) mittels Sonderzeichen abzugrenzen und zu strukturieren. 
Andere Programmiersprachen bedienen sich hier typischerweise Zeichen wie {, } und ;.\\
Haskell baut hingegen auf das sog. Layout, eine Art 2-dimensionaler Syntax.  Wer schon einmal Python und seine Konventionen zur EinrÃ¼ckung von BlÃ¶cken hinter for und if kennengelernt hat, wird hier Parallelen sehen. 
Die Regelungen zu Layout lauten wie folgt und werden vom Haskell-Compiler wÃ¤hrend der Parsing-Phase angewandt:
\begin{itemize}
\item The first token \textbf{after} a \Haskell{where/let} and the \textbf{first token of a top-level definition} define the upper-left corner of a box.
\item The first token left of the box closes the box (offside rule).
\item Insert a \textit{\{} before the box.
\item Insert a \textit{\}} after the box.
\item Insert a \textit{;} before each line that starts at left box border.
\end{itemize}
Die Anwendung dieser Regeln auf dieses Beispielprogramm:
\begin{minted}{Haskell}
let y   = a * b       
    f x = (x + y) / y 
in  f c + f d
\end{minted}

fÃ¼hrt zur Identifikation der folgenden Box:
\begin{verbatim}
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„â”„     
letâ”‚y   = a * b      
   â”‚f x = (x + y) / y
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„â”„     
\end{verbatim}
\Haskell{in  f c + f d}\\  
Das Token in in der letzten Zeile steht links von der Boxgrenze im Abseits (siehe die offside rule).  Der Parser fÃ¼hrt nun die Zeichen {, } und ; ein und verarbeitet das Programm so, als ob der Programmierer diese Zeichen explizit angegeben hÃ¤tte.  (Haskell kann alternativ Ã¼brigens auch in dieser sog. expliziten Syntax geschrieben werden â€” das ist aber sehr unÃ¼blich, hat negativen Einfluss aufs Karma und ist vor allem fÃ¼r den Einsatz in automatischen Programmgeneratoren gedacht.)\\
Die explizite Form des obigen Programmes lautet (nach den drei letzten Regeln):
\begin{minted}{Haskell}
let {y   = a * b       
    ;f x = (x + y) / y}
in  f c + f d 
\end{minted}     
Damit ist die Bedeutung des Programmes eindeutig und es ist klar, dass bspw. nicht das folgende gemeint war (in dieser alternativen Lesart ist das Token f aus der zweiten in die erste Zeile "gerutscht"):
\begin{minted}{Haskell}
let y = a * b f    
    x = (x + y) / y
in  f c + f d   
\end{minted}
Aus diesen Layout-Regeln ergeben sich recht einfache Richtlinien fÃ¼r das EinrÃ¼cken in Haskell-Programmen:
\begin{itemize}
\item Die Zeilen einer Definition auf dem Top-Level beginnen jeweils ganz links (Spalte 1) im Quelltext.
\item Lokale where / let-Definitionen werden um mindestens ein Whitespace (typisch: 2 oder 4 Spaces oder 1 Tab) eingerÃ¼ckt.
\item Es gibt in Haskell ein weiteres Keyword (do, wird spÃ¤ter thematisiert), das den gleichen Regeln wie where / let folgt.
\end{itemize}
Beste GrÃ¼ÃŸe,\\
\phantom{ }\qquad â€”Torsten Grust
\end{mdframed}
\subsection{Lists([a])}
\begin{itemize}
\item Recursive definition:
\begin{enumerate}
\item\Haskell{[]} ist a list (nil), type \Haskell{[] :: [a]}
\item\Haskell{x : xs} (head, tail) is a list, if \Haskell{x :: a}, and \Haskell{xs :: [a]}.\\
\phantom{ }\quad \Haskell{cons: (:) :: a -> [a] -> [a] -> [a]} with \Haskell{infixr : 5}
\end{enumerate}
\item Notation: \Haskell{3:(2:1:[])} $\equiv$ \Haskell{3:2:1:[]} $\equiv$ \Haskell{[3,2,1]}
\end{itemize}
\begin{minted}[bgcolor =bg]{Haskell}
[]
it :: [t]
[1]
it :: [Integer]
[1,2,3]
it :: [Integer]
['z']
"z"
it :: [Char]
['z','x']
"zx"
it :: [Char]
[] == ""
True
it :: Bool
[[1],[2,3]]
it :: [[Integer]]
[[1],[2,3],[]]
[[1],[2,3]]
it :: [[Integer]]
False:[]
[False]
it :: [Bool]
(False:[]):[]
it ::[[Bool]]
:t [(<),(<=),(>)]
[(<),(<=),(>)] :: Ord a => [a -> a-> Bool]
[(1,"one"),(2,"two"),(3,"three")]
it :: [(Integer,[Char])]
:t head
head :: [a] -> a
:t tail :: [a] -> [a]
head "It's a trap"
'I'
it :: Char
tail  "It's a trap"
"t's a trap"
it :: [Char]
reverse "Never odd or even"
"neve ro ddo reveN"
it :: [Char]
\end{minted}
\begin{itemize}
\item Law
$\forall $\texttt{xs}$ \ne$\Haskell{[]}: \Haskell{head xs : tail} = \texttt{xs}
\end{itemize}
\begin{minted}[bgcolor =bg]{Haskell}
:i String
type String = [Char]
\end{minted}
\subsection{Type Synonyms}
\begin{itemize}
\item Introduce your own type synonyms. (type names : {\em U}ppercase)
\Haskell{type} $t_1$ \Haskell{=} $t_2$
\end{itemize}
\begin{minted}{Haskell}
type Bits = [Integer]

type Predicate a = a -> Bool

bits :: Integer -> Bits
bits n | n == 0    =[0]
       | otherwise = (n `mod` 2) : bits (n `div`2)

isEven :: Predicate Integer
isEven n = head (bits n) == 0

main :: IO ()
main = print $ isEven 35
\end{minted}
Sequence (lists of enumerable elements)
\begin{itemize}
\item \Haskell{[x..y]} $\equiv$ \Haskell{[x,x+1,x+2,...,y]}

\begin{minted}[bgcolor= bg]{Haskell}
['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
\end{minted}
\item \Haskell{x,s..y}$\equiv$ \Haskell{[x,x+i,x+(2*i),...,y] where i = x-s}

\begin{minted}[bgcolor= bg]{Haskell}
[1,3..20]
[1,3,5,7,9,11,13,15,17,19]
[2,4..20]
[2,4,6,8,10,12,14,16,18,20]
\end{minted}
\item Infinite List \Haskell{[1..]}
\end{itemize}
\section{Vorlesung 4}
\subsection{Pattern Matching}
\emph{The} idiomatic way to define functions by cases:
\Haskell{f :: }$a_1$ \Haskell{->}$\ldots$\Haskell{->}$a_k$ \Haskell{-> b}\\
\Haskell{f} $p_{11} \ldots p_{1k} = e_1\\$
$\vdots\quad \vdots\quad \vdots\quad \vdots $\\
\Haskell{f} $p_{m1} \ldots p_{nk} = e_n$\\
For all $e_i$ \Haskell{:: b}
on $a_i$ call \Haskell{f} $x_1x_2\ldots x_k$ each $x_i$ is matched against patterns $p_{i1}\ldots p_{in}$ in order. Result is $e_r$ if the rth branch is the first in which all patterns match.\\
\begin{tabular}{lp{4cm}p{4cm}}
Pattern&Matches if\ldots&Bindings in $e_r$\\\hline
constant c&$x_1$ == c\\
variable v&always& v = $x_i$\\
wildcard \_ &always\\
tuple ($p_1,\ldots,p_n$)&components of $x_i$ match type component patterns& Those bound by the component patterns\\
$[]$& $x_i == []$\\
$p_1:p_2$&\Haskell{head} $x_1$ matches $p_1$, \Haskell{tail} $x_i$ matches $p_2$\\
$v@p$& p matches&those bound by $p$ and $v=x_i$
\end{tabular}\\
Note: In a pattern, a variable may only occur once (linear patterns only)
\begin{listing}
\caption{sum in Haskell}
\begin{minted}{Haskell}
--(1) if then else
sum' :: [Integer] -> Integer
sum' xs =
   if xs == [] then 0 else head xs + sum' (tail xs)
--(2) guards
sum'' :: [Integer] -> Integer
sum'' xs | xs == [] = 0
         | otherwise = head xs + sum'' (tail xs)
--(3) pattern matching
sum''' :: [Integer] -> Integer
sum''' []     = 0
sum''' (x:xs) = x + sum''' xs

main :: IO ()
main = do
  print $ sum' [1,2,3]
  print $ sum'' [1,2,3]
  print $ sum''' [1,2,3]
\end{minted}
\end{listing}
\begin{listing}\label{ageof.hs}
\caption{ageOf in Haskell}
\inputminted{Haskell}{ageOf.hs}
\end{listing}
\begin{listing}
\caption{take in Haskell}
\inputminted{Haskell}{take.hs}
\end{listing}
\begin{listing}
\caption{merge in Haskell}
\inputminted[]{Haskell}{merges.hs}
\end{listing}
\begin{listing}
\caption{mergeSort in Haskell}
\inputminted{Haskell}{mergesort.hs}
\end{listing}
\subsection{Pattern matching in expressions (case)}
\begin{minted}[escapeinside=@@]{Haskell}
case e of @$p_1$@ | @$q_{11}$@ -> @$e_{11}$@
          @$\vdots$@
          @$p_n$@ | @$q_{n1}$@ -> @$e_{n1}$@
\end{minted}
\clearpage
\section{Vorlesung 5}
\subsection{Algebraic Data Types (Sum of Product Types)}
\begin{itemize}
\item Recall: \Haskell{[]} and \Haskell{(:)} are the \emph{constructors} for Type \Haskell{[a]}
\item Can define entirely new Type T and its constructors $K_i$:
\subitem \begin{tabbing}
\Haskell{data T} $a_1\ a_2\ \ldots\ a_n $\=$ = K_1\ b{11}\ \ldots\ b_{1n_1}$\\
\>\  $| K_2\ b_{21}\ \ldots\ b_{2n_2}$\\
\>\  $\vdots\qquad \vdots$\\
\>\  $| K_r\ b_{r1}\ \ldots\ b_{rnr}$
\end{tabbing}
\item Defines \emph{Type constructor} T and r \emph{value constructor} with types
\item $\text{\Haskell{K}}_i$\Haskell{::}$b_{i1}\ldots\ b_{ini}$\Haskell{-> T}$a_1\ a_2\ldots\ a_n$
\item $K_i$ identifier with uppercase first letter or symbol starting with \Haskell{:}
\item Example: [weekday.hs]
\subitem - Sum (or enumeration, choice)
\end{itemize}
\begin{listing}[h!]
\caption{weekday.hs}
\inputminted{Haskell}{weekday.hs}
\end{listing}
\begin{minted}[bgcolor = bg]{Haskell}
Wed
No instance for (Show Weekday) arising from a use of print
Thu == Sun 
No instance for (Eq Weekday) arising from a use of '=='
Mon > Sat
No instance for (Ord Weekday) arising form a use of '>'
\end{minted}
\begin{itemize}
\item Add deriving \Haskell{(c,c,...,c)} to data declaration to define canonical (intuitive) operations:\\
\begin{tabular}{l|l}
c (class)&operations\\ \hline
\Haskell{Eq}&equality (\Haskell{==,/=})\\
\Haskell{Show}&printing (\Haskell{show})\\
\Haskell{Ord}&ordering  (\Haskell{<,<=,max})\\
\Haskell{Enum}&enumeration (\Haskell{[x..y]})\\
\Haskell{Bounded}& bounds (\Haskell{minBound,maxBound})
\end{tabular}
\end{itemize}
\begin{listing}[h!]
\caption{RockPaperScissors.hs}
\inputminted{Haskell}{RockPaperScissor.hs}
\end{listing}
\begin{listing}[h!]\label{sequence.hs}
\caption{sequence.hs}
\inputminted{Haskell}{sequence.hs}
\end{listing}
\begin{itemize}
\item Product, r = 1, $n_1 = 2$ (\ref{sequence.hs})
\item Sum of Products:
\subitem \Haskell{Maybe a} = \Haskell{Nothing | Just a}
\subitem \Haskell{data Either a b} = \Haskell{Left a | Right a}
\subitem \Haskell{List a = Nil} 
\subitem \phantom{List a}\ | \Haskell{Cons a (List a)}
\end{itemize}
\begin{listing}[h!]
\caption{cons.hs}
\inputminted{Haskell}{cons.hs}
\end{listing}
\begin{listing}[h!]
\caption{eval-compile-run.hs}
\inputminted{Haskell}{eval-compile-run.hs}
\end{listing}
\clearpage
\section{Vorlesung 6}
\subsection{Type Classes}
A Type class C defines a family of type signatures (''methods'') whichi all \emph{instances} of c must implement:\\
\begin{minted}[escapeinside=||]{Haskell}
class C where
|$f_1$| :: |$t_1$|
|$f_2$| :: |$t_2$|
   |$\vdots$|
|$f_n$| :: |$t_n$|
\end{minted}
The  $t_i$ \emph{must} mention a For any $f_i$, the class may provide default definitions (that instances may overwrite).\\
\begin{itemize}
\item Example
\begin{minted}{Haskell}
class Eq a where 
(==) :: a -> a -> Bool
(/=) :: a -> a -> Bool
x /= y = not (x == y)
x == y = not (x /= y)
\end{minted}
\end{itemize}
\subsection{Class Constraints}
A \emph{class constraint} \Haskell{e (a => :: t} (where t mentions a) says that e has type t \emph{only if} a is an instance of class C.\\
\begin{minted}[bgcolor=bg]{Haskell}
:t (+)
(+) :: Num a => a -> a -> a
:t print
print :: Show a => a -> IO ()
:hoogle +Data.List
Data.List sort :: Ord a => [a] -> [a]
:hoogle [(a,b)] -> a -> Maybe b
lookup :: Eq a => a -> a [(a,b)] -> Maybe b
\end{minted}
\begin{listing}[h!]
\inputminted{Haskell}{type-classes.hs}
\caption{Default implementation of Show, Ord and Enum}
\end{listing}
\subsection{Class inheritance}
Defining class $(c_1a,c_2a,\ldots)$ \Haskell{=>} (\Haskell{a where ...}) makes type class C a \emph{subclass} of the $c_1$ C inherits all methods of the $c_i$.\\
(\Haskell{a => t} implies $(c_1a,c_2a,\ldots,Ca)$\Haskell{=> t})
\clearpage
\includegraphics[scale=0.7]{classes.png}
\newpage
\subsection{Class Instances}
If type t implements the method of class C, t becomes an \emph{instance} of c:
\begin{minted}[escapeinside=||]{Haskell}
instance C t where
|$f_1$| = <def of |$f_1$|> --all f may be
       |$\vdots$|        --provided, minimal
|$f_n$| = <def of |$f_n$|> --complete definition
                --must be provided
\end{minted}
$\bullet$ Example:\\
\begin{minted}{Haskell}
instance Eq Bool where
  x == y = (x && y) || (not x && not y)

instance (Eq a, Eq b) => Eq (a,b) where
  (x1,y1) == (x2,y2) = x1 == x2 && y1 == y2

instance Eq a => Eq [a] where
  [] == []         = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _      == _      = False

\end{minted}
$\bullet$ An instance definition for type constructor t may formulate type constraints for its argument types: a, b ... :\\
\Haskell{instance} ($c_1a,c_2,c_3b,\ldots)$ \Haskell{=>} 
 \Haskell{(t a b) where}\\
\begin{minted}[bgcolor=bg]{Haskell}
:i Enum
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  	-- Defined in â€˜GHC.Enumâ€™
instance Enum Word -- Defined in â€˜GHC.Enumâ€™
instance Enum Ordering -- Defined in â€˜GHC.Enumâ€™
instance Enum Integer -- Defined in â€˜GHC.Enumâ€™
instance Enum Int -- Defined in â€˜GHC.Enumâ€™
instance Enum Char -- Defined in â€˜GHC.Enumâ€™
instance Enum Bool -- Defined in â€˜GHC.Enumâ€™
instance Enum () -- Defined in â€˜GHC.Enumâ€™
instance Enum Float -- Defined in â€˜GHC.Floatâ€™
instance Enum Double -- Defined in â€˜GHC.Floatâ€™
fromEnum 'A'
65
fromEnum 'B'
66
toEnum 65
Exception: Prelude.Enum.().toEnum: bad argument
:t toEnum 65
toEnum 65 :: Enum a => a
toEnum 65 :: Char
'A'
toEnum 0 :: Bool
False
toEnum 20 :: Double
20.0
\end{minted}
\begin{listing}
\caption{Rock paper Scissors with instances}
\inputminted{Haskell}{RockPaperScissor-inheritance.hs}
\end{listing}
\subsection{Deriving Class Instances}
\begin{itemize}
\item Automatically made user-defined data (data ...) intsances of classes $c_i \in \{\text{\Haskell{Eq, Ord, Enum,Bounded, Show, Read}}\}$
\begin{minted}[escapeinside=@@]{Haskell}
data T @$a_1$@ @$a_2$@ ... @$a_n$@ = ...
                       |
  deriving (@$c_1$@..,@$c_n$@)
\end{minted}
\end{itemize}
\inputminted{Haskell}{RockPaperScissor-deriving.hs}
\clearpage
\section{Vorlesung 7}
\subsection{Domain Specific Languages}
\begin{itemize}
\item ''small languages'' designed to easily and directly express the concepts/idioms of a given domain. \emph{Not} Turing-complete in general. 
\item Examples:\qquad
\begin{tabular}{l|l}
	Domain         & DSL               \\ \hline
	Os automation  & Shell scripts     \\
	Typesetting    & \TeX, \LaTeX      \\
	Queries        & SQL               \\
	Game Scripting & UnrealScript, Lua \\
	Parsing        & Bison, ANTLR
\end{tabular}
\item Functional Languages are good hosts for Embedded DSLs:
\subitem- algebraic data types (e.g model abstract syntax trees)
\subitem- higher-order functions (e.g control constructs)
\subitem- lightweight syntax (layout/whitespace, non-alphabetic identifiers)
\end{itemize}
Example: An embedded DSL for finite sets of integers:\\
\begin{minipage}{.85\textwidth}
\begin{minted}{Haskell}
type IntegerSet = ...
empty  :: IntegerSet
insert :: Integer    -> IntegerSet -> IntegerSet
delete :: Integer    -> IntegerSet -> IntegerSet
member :: Integer    -> IntegerSet -> Bool
\end{minted}
\end{minipage}%
\begin{minipage}{.15\textwidth}
$\Biggl\} $construct.\\ \ \\
$\}$ observer
\end{minipage}\\
\Haskell{member 3 (insert 1 (delete 3 (insert 2 (insert 3 empty))))} $\rightarrow$ \Haskell{False}\\
DSL: \textcircled{1} Library of functions, implementaion details exposed
\begin{listing}[h!]
\caption{library-exposed.hs}
\inputminted{Haskell}{library-exposed.hs}
\end{listing}
\subsection{Modules}
Group related definitions (names, types) in a single file (named \verb|M.hs|)
\begin{minted}{Haskell}
module M where
type Predicate a = a -> Bool
id :: a -> a
id = \x -> x
\end{minted}
Hierarchy : module A.B.C.M in file \verb|A/B/C/M.hs|
\begin{itemize}
\item definitions in other module M:\\
\subitem \Haskell{import M}
\item Explicit export Lists hode all other definitions
\subitem \Haskell{module M (id) where ...}
\subsubitem \Haskell{--type Predicate a not exported} 
\item Abstract data types: export algebraic datatypes, but \emph{not} its constructor functions
\subitem \Haskell{module M (Rose, leaf) where}
\subitem \Haskell{data Rose a = Node a [Rose a] --constructor Node not exported}
\subitem \Haskell{leaf :: a -> Rose a}
\subitem \Haskell{leaf x = Node x []}
\item Export constructors:
\subitem \Haskell{module M (Rose (Node), leaf) where ...}
\subitem \Haskell{module M (Rose (...), leaf)  where ...}
\item Qualified imports to partition space:
\subitem \Haskell{import qualified M [as Nickname]}
\subitem \Haskell{t :: M.Rose Char}
\subitem \Haskell{t = M.leaf 'x'}
\end{itemize}
\begin{minted}[bgcolor =bg]{Haskell}
:t fromJust
Not in scope: â€˜fromJustâ€™
import Data.Maybe
:t fromJust
fromJust :: Maybe a -> a

import qualified Data.Maybe
:t Data.Maybe.fromJust
Data.Maybe.fromJust :: Maybe a -> a

import qualified Data.Maybe as DM
:t DM.fromJust
DM.fromJust :: Maybe a -> a
\end{minted}
\begin{itemize}
\item Partially import module:
\subitem \Haskell{import Data.List (nub,maybe)}
\subitem \Haskell{import Prelude hiding (otherwise)}
\subitem \Haskell{otherwise :: Bool}
\subitem \Haskell{otherwise = False}
\end{itemize}
\begin{listing}[h!]
\caption{Two implementations of the SetLanguage module}
\inputminted{Haskell}{SetLanguage.hs}
\inputminted{Haskell}{SetlanguageFunction.hs}
\end{listing}
\clearpage
\section{Vorlesung 8}
\begin{itemize}
\item Shallow DSL embedding : Semantiics of DSL operations directly expressed in terms of a host language value (e.g list or characteristic function).
\subitem- constructors (\Haskell{empty,insert,delete}) perform the work, harder to add
\subitem- Observer (\Haskell{member}) trivial
\item \emph{Deep} DSL embedding: DSL operations build an abstract syntax Tree (AST) that represents applications and arguments
\subitem- constructors merely build the AST, very easy to add
\subitem- observer: interpret (traverse) the AST and perform the work
\end{itemize}
\begin{listing}[h!]
\caption{SetLanguageDeep.hs}
\inputminted{Haskell}{SetLanguageDeep.hs}
\end{listing}
\begin{minted}[bgcolor=bg]{Haskell}
:i Num
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  	-- Defined in â€˜GHC.Numâ€™
instance Num Word -- Defined in â€˜GHC.Numâ€™
instance Num Integer -- Defined in â€˜GHC.Numâ€™
instance Num Int -- Defined in â€˜GHC.Numâ€™
instance Num Float -- Defined in â€˜GHC.Floatâ€™
instance Num Double -- Defined in â€˜GHC.Floatâ€™
:t 42
42 :: Num a => a
default ()
42
<interactive>:5:1:
    No instance for (Num a0) arising from a use of â€˜itâ€™
    The type variable â€˜a0â€™ is ambiguous
    Note: there are several potential instances:
      instance Integral a => Num (GHC.Real.Ratio a)
        -- Defined in â€˜GHC.Realâ€™
      instance Num Integer -- Defined in â€˜GHC.Numâ€™
      instance Num Double -- Defined in â€˜GHC.Floatâ€™
      ...plus three others
    In the first argument of â€˜printâ€™, namely â€˜itâ€™
    In a stmt of an interactive GHCi command: print it
default (Integer,Rational, Double)
42
42
42 / 3
14 % 1
42.1
421 % 10
default (Integer,Double)
\end{minted}
\begin{listing}[h!]
\caption{ExprDeepNum.hs}
\inputminted{Haskell}{ExprDeepNum.hs}
\end{listing}
\begin{listing}[h!]
\caption{ExprDeepNum.hs}
\inputminted{Haskell}{ExprDeep.hs}
\end{listing}
\clearpage
\subsection{Generalized Algebraic Datatypes}
Idea :
\begin{itemize}
\item Encode the type of a DSL expression (here : Integer or Bool) in its \emph{Haskell type}
\item Use Haskell's type checker to ensure at \emph{compile time} that only well-typed DSL expressions are built:
\end{itemize}
\subsection{GADTs}
\begin{itemize}
\item Language extensions: \Haskell{{-# LANGUAGE GADTs #-}}
\item Define entirely new parameters \Haskell{Type T}, its (value) constructors $k_i$ and their type signatures
\begin{minted}[escapeinside=||]{Haskell}
data T |$a_1\ a_2\ \ldots\ a_n$| where
  |$k_1$| :: |$b_{11}$| -> ... |$b_{1n_1}$| -> T |$t_{11}\ t_{12} \ldots\ t_{1n}$|
  |$k_2$| :: |$b_{21}$| -> ... |$b_{2n_2}$| -> T |$t_{21}\ t_{22} \ldots\ t_{2n}$|
...
\end{minted}
\end{itemize}
\begin{listing}[h!]
\caption{ExprDeepTyped.hs}
\inputminted{Haskell}{ExprDeepTyped.hs}
\end{listing}
\clearpage
\section{Vorlesung 9}
\begin{listing}[h!]
\caption{ExprEmbedding.hs}
\inputminted{Haskell}{ExprEmbedding.hs}
\end{listing}
\begin{listing}
\caption{expr-embeddings.hs}
\inputminted{Haskell}{expr-embeddings.hs}
\end{listing}
\subsection{Shallow Embedding of a String Matching DSL}
\begin{itemize}
\item Pattern:
\begin{enumerate}[1.]
\item Given a string, a pattern returns a \emph{list of matches.} Match failure?\marginpar{Replace failure by a list of successes} return the \emph{empty list} (of matches)
\item A match consists of a value (e.g the match of characters, tokens parse tree) and the residual string to match\\
Thus: \Haskell{type Pattern a = String -> [(a,String)]}
\epigraph{A pattern of things is list of things and strings}{Torsten Grust, 10.12.2015}
\end{enumerate} 
\item DSL design:\\
\begin{tabular}{l|l}
Pattern& DSL Function \Haskell{Char -> String ([Char,String])}\\ \hline
match literal& \Haskell{lit :: Char -> Pattern Char}\\
match empty string& \Haskell{empty :: a -> Pattern a}\\
fail always & \Haskell{fail :: Pattern a}\\
alternative &\Haskell{alt :: Pattern a -> Pattern a -> Pattern a}\\
sequence &\Haskell{seq ::(a ->  b -> c)-> Pattern a -> Pattern b -> Pattern c}\\
repetition & \Haskell{Pattern a -> Pattern [a]}
\end{tabular}
\end{itemize}
\begin{listing}
\inputminted{Haskell}{PatternMatching.hs}
\end{listing}
\begin{listing}
\inputminted{Haskell}{pattern-match.hs}
\end{listing}
\clearpage
\section{Vorlesung 10}
\subsection{Lazy Evaluation}
To execute a programm, Haskell \emph{reduces} expression to values. Haskell uses \emph{normal order reduction} to select the next expression to reduce:
\begin{itemize}
\item The \emph{outermost} reducable expression (redex) is reduced first.
\item $\Rightarrow$ Function application are reduced first \emph{before} their arguments.
\item If no further redex is found, the expression is in \emph{normal form}. and reduction terminates.
\end{itemize}
\begin{minted}[escapeinside=||]{Haskell}
fst :: (a,b) -> a
fst (x,y) = x
sqr :: Num a => a -> a
sqr x = x * x
---------------
fst (sqr (1 + 3), sqr 2) |$\rightarrow$| sqr (1 + 3)        [fst]
                         |$\rightarrow$| (1 + 3) * (1 + 3)  [sqr]
                         |$\rightarrow$| 4 * 4              [+/+]
                         |$\rightarrow$| 16                 [*]
\end{minted}
\begin{minted}{racket}
(define-racket-procedures pair
  make-pair
  pair?
  (pair-fst)
  (pair-snd))

(define fst
  (lambda (p)
    (pair-fst p)))

(define sqr 
  (lambda (x) (* x x)))

;Racket uses applicative order reduction (innermost first)
\end{minted}
\begin{listing}[h!]
\caption{This Programm compiles in Haskell, but not in Racket}
\inputminted[]{Haskell}{bomb.hs}
\end{listing}
Haskell avoids the duplication of work through \emph{graph reduction}: Expression are shared (referenced more than once) instead of duplicated. Reduction of \Haskell{sqr (1 + 3)}:\\
\begin{tikzpicture}
\node at (0,0) {sqr};
\draw (0,0) -- (0,-1);
\node at (0,-1) {+};
\draw (0,-1) -- (0.25,-1.25);
\node at (0.25,-1.25) {3};
\draw (0,-1) -- (-0.25,-1.25);
\node at (-0.25,-1.25) {1};
\end{tikzpicture}$\rightarrow$
\begin{tikzpicture}
\node at (0,0) {*};
\draw (0,0) -- (0,-1);
\node at (0,-1) {+};
\draw (0,-1) -- (0.25,-1.25);
\node at (0.25,-1.25) {3};
\draw (0,-1) -- (-0.25,-1.25);
\node at (-0.25,-1.25) {1};
\end{tikzpicture}\\
Lazy evaluation: normal order reduction + sharing + WHNF\\
\emph{thunks}
\subsection{WHNF}
An expression $e$ ist in \emph{weak head normal form} (WHNF) if it is of the following form:\\
\newcommand{\iu}[1]{\textcircled{\raisebox{-0.1em}{#1}}}
\begin{enumerate}[\iu{1}]
\item \Haskell{v} (where \Haskell{v} is an \emph{atomic} value \Haskell{Integer, Char, Bool,...})
\item[\iu{2}] $c\ e_1\ e_2\ \ldots e_n$ (where $c$ is an n-ary constructor (like \Haskell{(:)} ))
\item[\iu{3}] $f\ e_1\ e_2 \ \ldots e_m$ (where f is a n-ary function, $m < n$)
\end{enumerate}
Haskell reduces values to WHNF only (stop criteria for reducion) unless we request reduction to normal fprm (e.g when printing result)\\
\subsection{Example expressions in WHNF}
\begin{minted}[escapeinside=||]{Haskell}
42 -- |\iu{1}|
(sqr 2,sqr 4) -- |\iu{2}|
f x = map f xs -- |\iu{2}| (:)
Just (40 + 2) -- |\iu{2}| Just
(* (40 + 2)) --  |\iu{3}| * binary
(\x -> 40 + 2) --  |\iu{3}| * binary
\end{minted}
\begin{minted}[bgcolor=bg]{Haskell}
(1 + 3) : []
[4]
it :: [Integer]
let xs = (1 + 3) : []
xs :: [Integer]
:sprint xs 
xs = [_]
\end{minted}
\subsection{Lazy Evaluation and Bottom ($\perp$)}
Some Haskell expressions have the value \emph{bottom} ($perp$) Examples: \Haskell{error ".."}, \Haskell{undefined}, \Haskell{bomb}. Lazy evaluation admits functions that return a non-bottom value even if they receive $\perp$ as an argument (also:{\em non-Strict functions }).
N-ary function is \emph{strict} in its i-th argument, if $f\ x_1\ \ldots\ x_{i-1} \perp x_{i+1} \ldots x_n = \perp$\\
Examples:
\begin{itemize}
\item \Haskell{const :: a -> b -> a} strict in first, non-strict in second argument
\item \Haskell{(&&) :: Bool -> Bool -> Bool}
\end{itemize}
$\bigtriangleup\! \hspace*{-0.45em}!\hspace*{0.45em}$ If a function \emph{pattern matches} an argument, Haskell semantics define it to be strict in that argument.\\
Example:\\
\begin{minted}[escapeinside=||]{Haskell}
data T = T Int
f :: T -> Int
f (T x) = 42
f undefined     |$\rightarrow$| undefined
f (T undefined) |$\rightarrow$| 42
\end{minted}
\begin{listing}[h!]
\inputminted{Haskell}{bottom.hs}
\caption{Bottom type}
\end{listing}
\begin{listing}[h!]
\inputminted{Haskell}{min.hs}
\caption{Finding the minimum by sorting the list}
\end{listing}
\begin{minted}[escapeinside=||]{Haskell}
min [8,6,1,7,5] |$\rightarrow$| (head . isort (<)) [8,6,1,7,5]  [min]
|$\rightarrow$| head (isort (<) [8,6,1,7,5])                    [(.)]
|$\rightarrow$| head (ins 8 (ins 6 (ins 1 (ins 7 (ins 5 []))))) [isort.2*]
|$\rightarrow$| head (ins 8 (ins 6 (ins 1(ins 7 [8]))))         [ins.1]
|$\rightarrow$| head (ins 8 (ins 6 (ins 1 (5 : ins 7 []))))     [ins.3]
|$\rightarrow$| head (ins 8 (1 : ins 6 ( 5 : ins 7 [])))        [ins.2]
|$\rightarrow$| (1 : ins 8 (ins 6 (5 : ins 7 [])))              [ins.3]
|$\rightarrow$| 1
\end{minted}
\begin{minted}[bgcolor=bg]{Haskell}
min [1..1000000]
1
it :: Integer
(1.50 secs, 521,738,256 bytes)
min [1..10000000]
1
it :: Integer
(15.43 secs, 5,164,721,896 bytes)
\end{minted}
\clearpage
\section{Vorlesung 11}
\subsection{Infinite Lists (Data Structures)}
One consequence of lazy evaluation, programs can handle \emph{infinite Lists} as long as any run will inspect onlt a finite prefix of such a list.\\
Enables a modular programming style:\\
\begin{enumerate}
\item \textbf{generator functions} produce an infinite number of solutions/approximations
\item \textbf{test functions} select one (or finite number of) solutions from this infinie list)
\end{enumerate}
Example: Newton-Raphson square root approximation
Iteratively approximate the square root of $x$
\begin{enumerate}
\item $a_0 = \nicefrac{x}{2}$
\item $a_{i+1} = \nicefrac{(a_i + \nicefrac{x}{a_i})}{2}$\hfill$a = (a + \nicefrac{x}{a}/2) \Leftrightarrow a = \sqrt{x}$
\end{enumerate}
\inputminted{Haskell}{sqrt.hs}
Example (Tic-Tac-Toe game tree):\\
Build the (potentially huge) \emph{tree of possible moevs} for the Tic-Tac-Toe Board game. Evaluate promise of game position.\\
Plan:\\
\begin{enumerate}
\item[\textcircled{1}] Find representation of game position (board + player next up)\\
\begin{tabular}{|l|l|l|}
\hline
1&2&3 \\ \hline
4&5&6 \\ \hline
X&O&X \\ \hline
\end{tabular}
\item[\textcircled{2}]provide pretty-printing for game
\item[\textcircled{3}]Define initial position and possible moves : \Haskell{moves :: Position -> [Position]}
\item[\textcircled{4}] Evaluate a given position: \Haskell{static :: Position -> Int}
\end{enumerate}
\inputminted{Haskell}{tic-tac-toe.hs}
\end{document}